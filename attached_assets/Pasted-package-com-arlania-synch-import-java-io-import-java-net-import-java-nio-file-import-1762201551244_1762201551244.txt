package com.arlania.synch;

import java.io.*;
import java.net.*;
import java.nio.file.*;
import java.util.*;
import java.util.zip.*;

import com.arlania.Client;
import com.google.gson.*;
import com.google.gson.annotations.SerializedName;

public class CacheUpdateManager {

	private static final String API_URL = "https://aragonrsps.com";
	public static final String CACHE_DIR = System.getProperty("user.home") + "/.aragon-caache/";
	private static final String MANIFEST_FILE = CACHE_DIR + "patches-manifest.json";

	private final Gson gson = new Gson();
	private final Client client;
	public CacheUpdateManager(Client client) {
		this.client = client;
	}
	
	public static void main(String[] args) {
		try {
			CacheUpdateManager cacheUpdateManager = new CacheUpdateManager(null);
			
			cacheUpdateManager.checkAndUpdateCache();
		} catch (Exception e) {
			// TODO: handle exception
		}
	}

	/**
	 * Main cache update method - checks for updates and downloads patches
	 */
	public boolean checkAndUpdateCache() {
		try {
			System.out.println("Checking for cache updates...");

			// Step 1: Check if we have a local manifest
			File manifestFile = new File(MANIFEST_FILE);
			String localVersion = null;

			if (manifestFile.exists()) {
				localVersion = getLocalVersion();
				System.out.println("Current local cache version: " + localVersion);
			} else {
				System.out.println("No local cache found - will download all patches");
			}

			// Step 2: Get latest version info from server
			LatestVersionInfo serverInfo = getLatestVersionFromServer();

			if (serverInfo == null || serverInfo.latestVersion == null) {
				System.err.println("Failed to connect to update server or invalid response.");
				return false;
			}

			System.out.println("Server cache version: " + serverInfo.latestVersion);

			// Step 3: Determine if we need to update
			if (localVersion != null && localVersion.equals(serverInfo.latestVersion)) {
				System.out.println("Cache is up to date!");
				return true;
			}

			// Step 4: Download patches
			if (localVersion == null) {
				System.out.println("Downloading all patches...");
				downloadAllPatches(serverInfo);
			} else {
				System.out.println("Downloading updates from " + localVersion + " to " + serverInfo.latestVersion);
				downloadIncrementalPatches(localVersion, serverInfo.latestVersion);
			}

			// Step 5: Update local manifest
			updateLocalManifest(serverInfo.latestVersion);
			System.out.println("Cache update complete! Version: " + serverInfo.latestVersion);
			return true;

		} catch (Exception e) {
			System.err.println("Cache update failed: " + e.getMessage());
			e.printStackTrace();
			return false;
		}
	}

	/**
	 * Reads the current version from the local manifest file.
	 */
	private String getLocalVersion() throws IOException {
		String content = new String(Files.readAllBytes(Paths.get(MANIFEST_FILE)));
		JsonObject manifest = gson.fromJson(content, JsonObject.class);

		if (manifest.has("version") && !manifest.get("version").isJsonNull()) {
			return manifest.get("version").getAsString();
		} else {
			System.err.println("Local manifest missing 'version' field â€” treating as fresh install.");
			return null;
		}
	}

	/**
	 * Fetches the latest version info from the server.
	 */
	private LatestVersionInfo getLatestVersionFromServer() {
		try {
			URL url = new URL(API_URL + "/admin/cache/patches/latest");
			HttpURLConnection conn = (HttpURLConnection) url.openConnection();
			conn.setRequestMethod("GET");
			conn.setConnectTimeout(10000);
			conn.setReadTimeout(10000);

			if (conn.getResponseCode() == 200) {
				BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
				StringBuilder response = new StringBuilder();
				String line;
				while ((line = reader.readLine()) != null) {
					response.append(line);
				}
				reader.close();

				System.out.println("Server JSON response: " + response);
				return gson.fromJson(response.toString(), LatestVersionInfo.class);
			} else {
				System.err.println("Server returned: " + conn.getResponseCode());
				return null;
			}
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}

	/**
	 * Download all patches (for a fresh installation).
	 */
	private void downloadAllPatches(LatestVersionInfo serverInfo) throws IOException {
		System.out.println("Downloading combined patches (all files)...");
		new File(CACHE_DIR).mkdirs();

		String requestBody = String.format(
				"{\"from_version\":\"0.0.0\",\"to_version\":\"%s\"}",
				serverInfo.latestVersion
				);

		downloadAndExtractPatch(
				API_URL + "/api/cache/patches/download-combined",
				requestBody,
				"POST"
				);
	}

	/**
	 * Download only the patches newer than the local version.
	 */
	private void downloadIncrementalPatches(String fromVersion, String toVersion) throws IOException {
		System.out.println("Downloading incremental patches...");
		LatestVersionInfo serverInfo = getLatestVersionFromServer();
		if (serverInfo == null || serverInfo.patches == null) {
			throw new IOException("Failed to get patch list from server");
		}

		List<LatestVersionInfo.PatchInfo> patchesToDownload = new ArrayList<>();
		for (LatestVersionInfo.PatchInfo patch : serverInfo.patches) {
			if (compareVersions(patch.version, fromVersion) > 0 &&
					compareVersions(patch.version, toVersion) <= 0) {
				patchesToDownload.add(patch);
			}
		}

		patchesToDownload.sort((p1, p2) -> compareVersions(p1.version, p2.version));

		for (int i = 0; i < patchesToDownload.size(); i++) {
			LatestVersionInfo.PatchInfo patch = patchesToDownload.get(i);
			System.out.printf("Downloading patch %d/%d: v%s%n",
					i + 1, patchesToDownload.size(), patch.version);
			downloadAndExtractSinglePatch(patch.id);
		}

		System.out.println("All incremental patches downloaded successfully!");
	}

	/**
	 * Download a single patch by version.
	 */
	private void downloadAndExtractSinglePatch(int patchId) throws IOException {
		String urlString = API_URL + "/api/cache/patches/" + patchId + "/download";
		URL url = new URL(urlString);
		HttpURLConnection conn = (HttpURLConnection) url.openConnection();
		conn.setRequestMethod("GET");
		conn.setConnectTimeout(10000);
		conn.setReadTimeout(30000);

		if (conn.getResponseCode() == 200) {
			File tempZip = new File(CACHE_DIR + "temp_patch_" + patchId + ".zip");

			try (InputStream in = conn.getInputStream();
					FileOutputStream out = new FileOutputStream(tempZip)) {
				byte[] buffer = new byte[8192];
				int bytesRead;
				long totalBytes = 0;

				while ((bytesRead = in.read(buffer)) != -1) {
					out.write(buffer, 0, bytesRead);
					totalBytes += bytesRead;
				}
				System.out.println("Downloaded v" + patchId + ": " + totalBytes + " bytes");
			}

			extractZipFile(tempZip, new File(CACHE_DIR));
			tempZip.delete();
		} else {
			throw new IOException("Failed to download patch " + patchId + ": " + conn.getResponseCode());
		}
	}

	/**
	 * Compare two semantic version strings.
	 */
	private int compareVersions(String v1, String v2) {
		String[] parts1 = v1.split("\\.");
		String[] parts2 = v2.split("\\.");
		int length = Math.max(parts1.length, parts2.length);
		for (int i = 0; i < length; i++) {
			int num1 = i < parts1.length ? Integer.parseInt(parts1[i]) : 0;
			int num2 = i < parts2.length ? Integer.parseInt(parts2[i]) : 0;
			if (num1 != num2) {
				return num1 - num2;
			}
		}
		return 0;
	}

	/**
	 * Download patch ZIP and extract it to the cache directory.
	 */
	private void downloadAndExtractPatch(String urlString, String requestBody, String method) throws IOException {
		URL url = new URL(urlString);
		HttpURLConnection conn = (HttpURLConnection) url.openConnection();
		conn.setRequestMethod(method);
		conn.setDoOutput(true);
		conn.setRequestProperty("Content-Type", "application/json");

		if ("POST".equals(method) && requestBody != null) {
			try (OutputStream os = conn.getOutputStream()) {
				os.write(requestBody.getBytes("UTF-8"));
			}
		}

		if (conn.getResponseCode() == 200) {
			File tempZip = new File(CACHE_DIR + "temp_patch.zip");

			try (InputStream in = conn.getInputStream();
					FileOutputStream out = new FileOutputStream(tempZip)) {
				int fileSize = conn.getContentLength();
				byte[] buffer = new byte[8192];
				int bytesRead;
				long totalBytes = 0;
				while ((bytesRead = in.read(buffer)) != -1) {
					out.write(buffer, 0, bytesRead);
					totalBytes += bytesRead;
					int progress = (int) ((totalBytes * 100) / fileSize);
					update(progress, "Fetching update from server. ");
					if (totalBytes % (1024 * 1024) == 0) {
						System.out.println("Downloaded: " + (totalBytes / 1024 / 1024) + " MB");
					}
				}
				System.out.println("Download complete: " + totalBytes + " bytes");
			}

			extractZipFile(tempZip, new File(CACHE_DIR));
			tempZip.delete();

		} else {
			throw new IOException("Failed to download patch: " + conn.getResponseCode());
		}
	}

	/**
	 * Extract ZIP file preserving directory structure.
	 */
	private void extractZipFile(File zipFile, File destDir) throws IOException {
		System.out.println("Extracting patch files...");
		byte[] buffer = new byte[8192];
		int filesExtracted = 0;
		long totalSize = Files.size(Paths.get(zipFile.getAbsolutePath()));
		long extractedSize = 0;
		try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile))) {
			ZipEntry entry;
			while ((entry = zis.getNextEntry()) != null) {
				File newFile = new File(destDir, entry.getName());
				if (entry.isDirectory()) {
					newFile.mkdirs();
				} else {
					new File(newFile.getParent()).mkdirs();
					try (FileOutputStream fos = new FileOutputStream(newFile)) {
						int len;
						while ((len = zis.read(buffer)) > 0) {
							fos.write(buffer, 0, len);  
							extractedSize += len;
							int progress = (int) ((extractedSize * 100) / totalSize);
							update(progress, "Unpackaging cache files.");
						}
					}

					filesExtracted++;
					if (filesExtracted % 100 == 0) {
						System.out.println("Extracted: " + filesExtracted + " files");
					}
				}
				zis.closeEntry();
			}
		}

		System.out.println("Extraction complete: " + filesExtracted + " files extracted");
	}

	/**
	 * Update local patches-manifest.json safely.
	 */
	private void updateLocalManifest(String version) throws IOException {
		if (version == null || version.isEmpty()) {
			System.err.println("Warning: Tried to update manifest with null/empty version!");
			version = "unknown";
		}

		JsonObject manifest = new JsonObject();
		manifest.addProperty("version", version);
		manifest.addProperty("updated_at", System.currentTimeMillis());

		Files.write(Paths.get(MANIFEST_FILE), gson.toJson(manifest).getBytes());
		System.out.println("Updated local manifest to version: " + version);
	}

	private void update(int percent, String status) {
		if(percent >= 100)
			percent = 100;
		client.setLoadingText(percent, percent + "% - " +  status);
	}

	/**
	 * Server response structure.
	 */
	private static class LatestVersionInfo {
		@SerializedName("latest_version")
		String latestVersion;

		
		PatchInfo[] patches;

		static class PatchInfo {

	        int id;  // Add the id field here
			
			String version;

			@SerializedName("is_base")
			boolean isBase;

			long size;

			@SerializedName("file_count")
			int fileCount;

			@SerializedName("created_at")
			String createdAt;

			// Optional extra fields
			String patchType;
			String basedOnVersion;
			long totalSize;
			long compressedSize;
		}
	}
}
